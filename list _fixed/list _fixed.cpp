#pragma once
#include <iostream>
#include "list.cpp"

//Этот код односвязного списка
//Этот список умеет совсем немного.
//Добавлять элементы в конец себя и печатать себя.

/*
    Поработайте над вашей реализацией списка:
    Рационально распределите поля по private и public секциям.
    Снабдите его конструктором копирования.
    Поработайте над типами принимаемых и возвращаемых методами значений (значения, указатели, ссылки, +константность).
    Во всех заданиях необходимо рационально распределить код по файлам.
    Проект списка вынесите из папки со второй неделей, и разместите в корне репозитория( там, где недели).
    В папках с неделями его(и его более старых версий) остаться не должно.
    */










//std::pair<list*, list*> split_list(list* cur_list)

/* Функциями удаления элементов из начала и из конца.
        Указателем на выбранный(текущий) элемент
        (Кроме указателя на первый и последний появляется еще один, по умолчанию пусть смотрит на первый)
        Возможностью 
        - вставить элемент после текущего
        - удалить текущий элемент
        - перемещать текущий(указатель на него) элемент по списку
        */

int main()
{
    list l;
    std::cout << l.is_list_empty() << std::endl;

    l.pushback(28);
    l.pushback(37);
    l.print_list();
    l.delete_back();
    l.print_list();
    l.delete_back();
    l.print_list();
    l.delete_back();



    // Проверка добавления с начала
    l.pushfront(377);
    std::cout << "Old list: ";
    l.print_list();

    list list2 = list(l);
    std::cout << "New list: ";
    list2.print_list();
    //split
    list* l1 = split_list(&l);
    l1->print_list();
    l.print_list();

    std::cout << l.is_list_empty() << std::endl;
    std::cout << l.get_first();

    

    return 0;

    /*РЕфакторинг списка!
    Внесите функции для работы со списком внутрь структуры (должны стать функциями членами).
    Научите ваш список биться на 2 списка по текущему элементу.
    Приведите названия переменных и функций к единообразному виду.
    Кратко сформулируйте в комментариях в коде принципы, на основе которых вы именовали объекты.
    Приведите main(); к 'правильному' состоянию (демонстрируется корректная работа всех функций, программа объясняет пользователю что происходит)
    Дополните структуру list списка деструктором, не допускающим утечек памяти.
    */


    

};